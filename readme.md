## Текст задания

Есть база в PostgreSQL, содержащая три таблицы:
  * `products` (product | provider | price) - содержит соответствие наименования продукта, провайдера и цены.
  * `credits` (provider | credit) - текущий баланс провайдера.
  * `order` (product | provider | price | datetime) - заказы.

Нужно написать на Node.js обработчик запросов (node-server), реализующий следующий функционал:

1. Принимает запрос типа `POST` на URI `/booking`.
2. В теле запроса передается `application/json` с названием продукта: `{name: <product>}`.
3. Находит поставщика (`provider`), который может поставить данный продукт за минимальную цену.
4. При этом кредит у данного провайдера должен быть не меньше стоимости продукта, иначе нужно искать другой вариант.
5. Уменьшает кредит провайдера на сумму, равную стоимости продукта.
6. Записывает в `order` продукт, провайдера и стоимость.
7. В случае успешного создания заказа сервер должен отдавать `200 OK` с `id` заказа.
8. В случае ошибки -- `500` и json-сообщение об ошибке, например: `{"error":"No such product 'product-name'."}`

При выполнении задачи следует учесть нюансы:

* Может поступать несколько одновременных входящих запросов.
* Может быть запущено одновременно несколько node-серверов, работающих с одной базой данных.
* Кредиты у провайдеров не должны становиться меньше нуля.
* **Можно вносить изменения в структуру базы данных. Изменения желательно сопровождать комментариями.**
* Если были внесены изменения в структуру БД, нужно прикрепить новый дамп или файл с sql-запросами.
* Если используются миграции (например, `sequelize`), дамп можно не прикреплять.
* Сервер должен запускаться на порту `3000` командой `npm start`.


## Изменения в БД

1. Изменения можно накатить запустив `sh ./bin/db.setup.sh` или командой `npm run setup`.
2. Выполнена нормализация. Вместо 3 таблиц создано 4:
  * `product` (product_id, name)
  * `vendor` (vendor_id, name, credit)
  * `offer` (offer_id, product_id, vendor_id, price)
  * `purchase` (purchase_id, offer_id, datetime)
3. Для всех таблиц добавлены PK, индексы и сиквенсы.
4. Для всех FK созданы индексы, но сами FK, как ограничение не используются (не были созданы намеренно).
5. Для значений, хранящих деньги `vendor.credit` и `offer.price`, выбран тип `BIGINT`.
6. Предполагается, что деньги будут храниться в минимальной единице измерения. Например в копейках или центах.
7. Для столбца `purchase.datetime` выбран тип `TIMESTAMP WITHOUT TIME ZONE DEFAULT (NOW() AT TIME ZONE 'UTC')`.
8. Таблица `order` переименована в `purchase`, чтобы не таскать двойные кавычки. Т.к. `order` -- ключевое слово.
